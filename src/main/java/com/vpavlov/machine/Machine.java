package com.vpavlov.machine;

import com.vpavlov.services.machine.exceptions.StartStateSetException;
import com.vpavlov.services.machine.exceptions.TransitionsExistException;
import com.vpavlov.services.machine.api.TitleGenerator;

import java.util.*;

/**
 * Class represents a deterministic state machine
 *
 * @author vpavlov
 * @version 20.11.2022
 */
public class Machine {

    /**
     * Map of the machine states
     */
    private final Map<String, State> states;

    /**
     * Final states of the machine
     */
    private final Set<State> finalStates;

    /**
     * Current state of the machine
     */
    private State currentState = null;

    /**
     * Start state of the machine
     */
    private State startState = null;

    /**
     * Alphabet of the machine
     */
    private final Alphabet alphabet;

    /**
     * Count of the machine states
     */
    private int statesCount = 0;

    /**
     * Machine state title generator
     */
    private final TitleGenerator titleGenerator;

    /**
     * Constructor
     *
     * @param alphabet       alphabet of the machine
     * @param titleGenerator machine state title generator
     */
    public Machine(Alphabet alphabet, TitleGenerator titleGenerator) {
        this.states = new HashMap<>();
        this.finalStates = new HashSet<>();
        this.titleGenerator = titleGenerator;
        this.alphabet = alphabet;
    }

    /**
     * Deep copy constructor
     *
     * @param machine a machine to copy
     */
    public Machine(Machine machine) {
        this.currentState = null;
        this.alphabet = machine.alphabet;
        this.titleGenerator = machine.titleGenerator;
        this.statesCount = machine.statesCount;
        this.states = copyStates(machine.states);
        this.startState = states.get(machine.startState.getTitle());
        this.finalStates = copyFinalStates(machine.finalStates);
        copyTransitions(machine.states);
        System.out.printf("Source machine:\n%s", machine);
        System.out.printf("Copied machine:\n%s", this);
    }

    /**
     * Creates deep copy of specified machine final states
     *
     * @param finalStates final states to copy
     * @return deep copy of specified machine final states
     */
    private Set<State> copyFinalStates(Set<State> finalStates) {
        Set<State> newFinalStates = new HashSet<>();
        for (State state : finalStates) {
            newFinalStates.add(states.get(state.getTitle()));
        }

        return newFinalStates;
    }

    /**
     * Deep copy of transitions of specified machine states
     *
     * @param states states to copy transitions for
     */
    private void copyTransitions(Map<String, State> states) {

        for (State state : states.values()) {
            State newToState = this.states.get(state.getTitle());
            copyTransitionsIn(newToState, state.getTransitionsIn());
        }
    }

    /**
     * Deep copy of "in" transitions  of specified machine state and transitions
     *
     * @param toState     specified state
     * @param transitions transitions to specified state
     */
    private void copyTransitionsIn(State toState, Map<String, Set<State>> transitions) {
        for (String symbol : transitions.keySet()) {
            Set<State> states = transitions.get(symbol);
            for (State fromState : states) {
                State newFromState = this.states.get(fromState.getTitle());
                toState.addTransitionIn(symbol, newFromState);
                newFromState.addTransitionOut(symbol, toState);
            }
        }
    }

    /**
     * Creates deep copy of specified machine states
     *
     * @param states states to deep copy
     * @return deep copy of specified machine states
     */
    private Map<String, State> copyStates(Map<String, State> states) {
        Map<String, State> statesCopies = new HashMap<String, State>();
        for (State state : states.values()) {
            statesCopies.put(state.getTitle(), new State(state));
        }

        return statesCopies;
    }

    /**
     * Add new machine state with autogenerated title using title generator
     *
     * @see com.vpavlov.services.machine.api.TitleGenerator
     */
    public void addState() {
        String title = titleGenerator.generateTitle(statesCount);
        states.put(title, new State(title));
        ++statesCount;
    }

    /**
     * Add new machine state with specified title
     *
     * @param title a new state title
     */
    public void addState(String title) {
        states.put(title, new State(title));
        ++statesCount;
    }

    /**
     * Add final state to the machine
     *
     * @param title the title of the state to be added to final states
     */
    public void addFinalState(String title) {
        finalStates.add(states.get(title));
    }

    /**
     * Remove state with specified title from final states of the machine
     *
     * @param title the title of the state to be removed from final states
     */
    public void removeFinalState(String title) {
        finalStates.remove(states.get(title));
    }

    /**
     * Add new transitions to the machine with specified symbols
     *
     * @param symbols symbols of the transition to be added
     * @param from    the title of the state from which the transition will be
     * @param to      the title of the state to which the transition will be
     * @return true if the transition was added, else false
     * @throws TransitionsExistException if the transition with specified symbols is already exists
     */
    public boolean addTransitions(Collection<String> symbols, String from, String to) throws TransitionsExistException {
        State fromState = states.get(from);
        State toState = states.get(to);
        if (fromState == null || toState == null || !alphabet.containsAll(symbols)) {
            //no states with specified titles or invalid symbol
            return false;
        }

        Map<String, String> exitingTransitions = getExistingTransitions(symbols, from);
        if (!exitingTransitions.isEmpty()) {
            throw new TransitionsExistException(fromState.getTitle(), exitingTransitions);
        }

        for (String symbol : symbols) {
            fromState.addTransitionOut(symbol, toState);
            toState.addTransitionIn(symbol, fromState);
        }
        return true;
    }

    /**
     * Add new transitions to the machine with specified symbols and replace existing transitions with new ones
     *
     * @param symbols symbols of the transitions to be added
     * @param from    the title of the state from which the transition will be
     * @param to      the title of the state to which the transition will be
     * @return true if the transition was added, else false
     */
    public boolean addAndReplaceTransitions(Collection<String> symbols, String from, String to) {
        State fromState = states.get(from);
        State toState = states.get(to);
        if (fromState == null || toState == null || !alphabet.containsAll(symbols)) {
            //no states with specified titles or invalid symbol
            return false;
        }
        for (String symbol : symbols) {
            fromState.addTransitionOut(symbol, toState);
            toState.addTransitionIn(symbol, fromState);
        }
        return true;
    }

    /**
     * Gets exiting transitions with specified symbols from specified state
     *
     * @param symbols transitions symbols
     * @param from    the title of the state from which the transitions will be got
     * @return map of exiting transitions [transition symbol, to state title]
     */
    public Map<String, String> getExistingTransitions(Collection<String> symbols, String from) {
        State fromState = states.get(from);
        Map<String, String> exitingTransitions = new HashMap<>();
        for (String symbol : symbols) {
            State existingState = fromState.getTransitionOut(symbol);
            if (existingState != null) {
                exitingTransitions.put(symbol, existingState.getTitle());
            }
        }

        return exitingTransitions;
    }

    /**
     * Check if all states of the machine are completed
     *
     * @return true if all states are completed, else false
     */
    public boolean isCompleteStates() {
        for (State state : states.values()) {
            for (String symbol : alphabet.getSymbols()) {
                if (state.getTransitionOut(symbol) == null) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Check if start set is set
     *
     * @return true if start set is set, else false
     */
    public boolean isStartStateSet() {
        return startState != null;
    }

    /**
     * Check if at least one final state is set
     *
     * @return true if at least one final state is set, else false
     */
    public boolean isFinalStatesSet() {
        return !finalStates.isEmpty();
    }

    /**
     * Set the machine start state
     *
     * @param title the title of the state to be set as a start state
     * @throws StartStateSetException if the start state is already set
     */
    public void setStartState(String title) throws StartStateSetException {
        if (this.startState == null) {
            this.startState = states.get(title);
            this.currentState = this.startState;
        } else {
            throw new StartStateSetException(startState.getTitle());
        }
    }

    /**
     * Set the machine start state and override exiting start state
     *
     * @param title the title of the state to be set as a start state
     * @return the title of the previous start state if it exists, else null
     */
    public String overrideStartNode(String title) {
        State previous = startState;
        startState = states.get(title);
        currentState = startState;
        if (previous != null) {
            return previous.getTitle();
        } else {
            return null;
        }
    }

    /**
     * Remove the machine start state
     */
    public void removeStartState() {
        this.startState = null;
        this.currentState = null;
    }

    /**
     * The machine start state getter
     *
     * @return the title of the machine start state if it is set, else null
     */
    public String getStartState() {
        if (startState != null) {
            return startState.getTitle();
        } else {
            return null;
        }
    }

    /**
     * Makes the machine transition with specified symbol
     *
     * @param symbol symbol to make transition for
     * @return the title of the current state after the transition
     */
    public String transition(String symbol) {
        State current = states.get(currentState.getTitle());
        currentState = current.getTransitionOut(symbol);
        return currentState.getTitle();
    }

    /**
     * Removes transitions with specified symbols and with specified states
     *
     * @param from    the title of the state from which the transitions are
     * @param to      the title of the state to which the transitions are
     * @param symbols the symbols of the transitions
     */
    public void removeTransitions(String from, String to, Collection<String> symbols) {
        State fromState = states.get(from);
        State toState = states.get(to);
        for (String symbol : symbols) {
            fromState.removeTransitionOut(symbol);
            toState.removeTransitionIn(symbol, fromState);
        }
    }

    /**
     * Removes state with specified symbol
     *
     * @param title the title of the state to be removed
     * @return true if the state was removed, else false
     */
    public boolean removeState(String title) {
        --statesCount;
        State state = states.get(title);
        if (state == null) {
            return false;
        }
        state.removeAllTransitions();
        states.remove(title);
        renameStates(title);
        return true;
    }

    /**
     * Renames states after a stat was removed
     *
     * @param removedTitle the title of the state which was removed
     */
    private void renameStates(String removedTitle) {
        Set<State> renamedStates = new HashSet<>();
        for (State state : states.values()) {
            if (state.getTitle().compareTo(removedTitle) > 0) {
                String newTitle = String.valueOf((char) (state.getTitle().charAt(0) - 1));
                state.rename(newTitle);
                renamedStates.add(state);
            }
        }
        for (State state : renamedStates) {
            states.put(state.getTitle(), state);

        }
        states.remove(titleGenerator.generateTitle(statesCount));
    }

    /**
     * Set the machine current state
     * @param title the title od the state to be set as current
     *
     * @return true if the machine current state was set, else false
     */
    public boolean setCurrentState(String title) {
        currentState = states.get(title);
        return currentState != null;
    }

    /**
     * The machine current state getter
     * @return the title of the machine current state
     */
    public String getCurrentState() {
        return currentState.getTitle();
    }

    /**
     * Check if the machine current state is a final state
     * @return true if the machine current state is a final state, else false
     */
    public boolean isFinalState() {
        return finalStates.contains(currentState);
    }

    /**
     * Reset the machine (set the start state as current state)
     */
    public void reset() {
        currentState = startState;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("Start state: %s\n\n", startState.getTitle()));
        for (State state : states.values()) {
            sb.append(state.toString()).append("\n\n");
        }

        return sb.toString();
    }
}
